// This file is autogenerated by the hyperschema compiler
// Schema Version: 1
/* eslint-disable camelcase */
/* eslint-disable quotes */

const { c } = require('hyperschema/runtime')
const external0 = require('../../lib/encodings.js')

const VERSION = 1

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @autobase/checkout
const encoding0 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)

    return {
      key: r0,
      length: r1
    }
  }
}

// @autobase/clock
const encoding1 = c.array(encoding0)

// @autobase/indexCheckpoint
const encoding2 = {
  preencode (state, m) {
    c.fixed64.preencode(state, m.signature)
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    c.fixed64.encode(state, m.signature)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const r0 = c.fixed64.decode(state)
    const r1 = c.uint.decode(state)

    return {
      signature: r0,
      length: r1
    }
  }
}

const encoding3 = external0.Wakeup

// @autobase/wakeupv2
const encoding4 = {
  preencode (state, m) {
    c.uint.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.writers) encoding1.preencode(state, m.writers)
  },
  encode (state, m) {
    const flags = m.writers ? 1 : 0

    c.uint.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.writers) encoding1.encode(state, m.writers)
  },
  decode (state, version) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      type: r0,
      writers: (flags & 1) !== 0 ? encoding1.decode(state) : null
    }
  }
}

// @autobase/wakeup
const encoding5 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding3.preencode(state, m)
        break
      case 2:
        encoding4.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding3.encode(state, m)
        break
      case 2:
        encoding4.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1: {
        const decoded = encoding3.decode(state, version)
        return decoded
      }
      case 2: {
        const decoded = encoding4.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

const encoding6 = external0.BootRecord

// @autobase/bootRecordv4
const encoding7 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 4 so always one byte

    if (m.recoveries) c.uint.preencode(state, m.recoveries)
  },
  encode (state, m) {
    const flags =
      (m.indexersUpdated ? 1 : 0) |
      (m.fastForwarding ? 2 : 0) |
      (m.recoveries ? 4 : 0)

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)

    if (m.recoveries) c.uint.encode(state, m.recoveries)
  },
  decode (state, version) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      key: r0,
      systemLength: r1,
      indexersUpdated: (flags & 1) !== 0,
      fastForwarding: (flags & 2) !== 0,
      recoveries: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @autobase/bootRecord
const encoding8 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
      case 2:
      case 3:
        encoding6.preencode(state, m)
        break
      case 4:
        encoding7.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
      case 2:
      case 3:
        encoding6.encode(state, m)
        break
      case 4:
        encoding7.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1:
      case 2:
      case 3: {
        const decoded = encoding6.decode(state, version)
        return decoded
      }
      case 4: {
        const decoded = encoding7.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/checkpointer
const encoding9 = {
  preencode (state, m) {
    c.uint.preencode(state, m.checkpointer)
    state.end++ // max flag is 1 so always one byte

    if (m.checkpoint) encoding2.preencode(state, m.checkpoint)
  },
  encode (state, m) {
    const flags = m.checkpoint ? 1 : 0

    c.uint.encode(state, m.checkpointer)
    c.uint.encode(state, flags)

    if (m.checkpoint) encoding2.encode(state, m.checkpoint)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      checkpointer: r0,
      checkpoint: (flags & 1) !== 0 ? encoding2.decode(state) : null
    }
  }
}

// @autobase/checkpointerArray
const encoding10 = c.array(encoding9)

// @autobase/checkpoint
const encoding11 = {
  preencode (state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.system) encoding9.preencode(state, m.system)
    if (m.encryption) encoding9.preencode(state, m.encryption)
    if (m.user) encoding10.preencode(state, m.user)
  },
  encode (state, m) {
    const flags =
      (m.system ? 1 : 0) |
      (m.encryption ? 2 : 0) |
      (m.user ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.system) encoding9.encode(state, m.system)
    if (m.encryption) encoding9.encode(state, m.encryption)
    if (m.user) encoding10.encode(state, m.user)
  },
  decode (state) {
    const flags = c.uint.decode(state)

    return {
      system: (flags & 1) !== 0 ? encoding9.decode(state) : null,
      encryption: (flags & 2) !== 0 ? encoding9.decode(state) : null,
      user: (flags & 4) !== 0 ? encoding10.decode(state) : null
    }
  }
}

// @autobase/indexer
const encoding12 = {
  preencode (state, m) {
    c.uint.preencode(state, m.signature)
    c.fixed32.preencode(state, m.namespace)
    c.fixed32.preencode(state, m.publicKey)
  },
  encode (state, m) {
    c.uint.encode(state, m.signature)
    c.fixed32.encode(state, m.namespace)
    c.fixed32.encode(state, m.publicKey)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const r1 = c.fixed32.decode(state)
    const r2 = c.fixed32.decode(state)

    return {
      signature: r0,
      namespace: r1,
      publicKey: r2
    }
  }
}

// @autobase/indexers
const encoding13 = c.array(encoding12)

// @autobase/digest
const encoding14 = {
  preencode (state, m) {
    c.uint.preencode(state, m.pointer)
    state.end++ // max flag is 1 so always one byte

    if (m.key) c.fixed32.preencode(state, m.key)
  },
  encode (state, m) {
    const flags = m.key ? 1 : 0

    c.uint.encode(state, m.pointer)
    c.uint.encode(state, flags)

    if (m.key) c.fixed32.encode(state, m.key)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      pointer: r0,
      key: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/node
const encoding15 = {
  preencode (state, m) {
    encoding1.preencode(state, m.heads)
    c.uint.preencode(state, m.batch)
    c.buffer.preencode(state, m.value)
  },
  encode (state, m) {
    encoding1.encode(state, m.heads)
    c.uint.encode(state, m.batch)
    c.buffer.encode(state, m.value)
  },
  decode (state) {
    const r0 = encoding1.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.buffer.decode(state)

    return {
      heads: r0,
      batch: r1,
      value: r2
    }
  }
}

// @autobase/additionalData
const encoding16 = {
  preencode (state, m) {
    state.end++ // max flag is 2 so always one byte
  },
  encode (state, m) {
    const flags =
      (m.encryptionId ? 1 : 0) |
      (m.abi ? 2 : 0)

    c.uint.encode(state, flags)
  },
  decode (state) {
    const flags = c.uint.decode(state)

    return {
      encryptionId: (flags & 1) !== 0,
      abi: (flags & 2) !== 0
    }
  }
}

// @autobase/additional.data
const encoding17_1 = c.frame(encoding16)

// @autobase/additional
const encoding17 = {
  preencode (state, m) {
    c.uint.preencode(state, m.pointer)
    state.end++ // max flag is 1 so always one byte

    if (m.data) encoding17_1.preencode(state, m.data)
  },
  encode (state, m) {
    const flags = m.data ? 1 : 0

    c.uint.encode(state, m.pointer)
    c.uint.encode(state, flags)

    if (m.data) encoding17_1.encode(state, m.data)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      pointer: r0,
      data: (flags & 1) !== 0 ? encoding17_1.decode(state) : null
    }
  }
}

const encoding18 = external0.OplogMessage

// @autobase/oplogMessagev2.checkpoint
const encoding19_0 = c.frame(encoding11)
// @autobase/oplogMessagev2.digest
const encoding19_1 = c.frame(encoding14)

// @autobase/oplogMessagev2
const encoding19 = {
  preencode (state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.checkpoint) encoding19_0.preencode(state, m.checkpoint)
    if (m.digest) encoding19_1.preencode(state, m.digest)
    encoding15.preencode(state, m.node)
  },
  encode (state, m) {
    const flags =
      (m.checkpoint ? 1 : 0) |
      (m.digest ? 2 : 0) |
      (m.optimistic ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.checkpoint) encoding19_0.encode(state, m.checkpoint)
    if (m.digest) encoding19_1.encode(state, m.digest)
    encoding15.encode(state, m.node)
  },
  decode (state, version) {
    const flags = c.uint.decode(state)

    return {
      version,
      checkpoint: (flags & 1) !== 0 ? encoding19_0.decode(state) : null,
      digest: (flags & 2) !== 0 ? encoding19_1.decode(state) : null,
      optimistic: (flags & 4) !== 0,
      node: encoding15.decode(state)
    }
  }
}

// @autobase/oplogMessage
const encoding20 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding18.preencode(state, m)
        break
      case 2:
        encoding19.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding18.encode(state, m)
        break
      case 2:
        encoding19.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1: {
        const decoded = encoding18.decode(state, version)
        return decoded
      }
      case 2: {
        const decoded = encoding19.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/pendingIndexers
const encoding21 = c.array(c.fixed32)

const encoding22 = external0.Info

// @autobase/infov2
const encoding23 = {
  preencode (state, m) {
    c.uint.preencode(state, m.members)
    encoding21.preencode(state, m.pendingIndexers)
    encoding1.preencode(state, m.indexers)
    encoding1.preencode(state, m.heads)
    encoding1.preencode(state, m.views)
    c.uint.preencode(state, m.encryptionLength)
    state.end++ // max flag is 1 so always one byte

    if (m.entropy) c.fixed32.preencode(state, m.entropy)
  },
  encode (state, m) {
    const flags = m.entropy ? 1 : 0

    c.uint.encode(state, m.members)
    encoding21.encode(state, m.pendingIndexers)
    encoding1.encode(state, m.indexers)
    encoding1.encode(state, m.heads)
    encoding1.encode(state, m.views)
    c.uint.encode(state, m.encryptionLength)
    c.uint.encode(state, flags)

    if (m.entropy) c.fixed32.encode(state, m.entropy)
  },
  decode (state, version) {
    const r0 = c.uint.decode(state)
    const r1 = encoding21.decode(state)
    const r2 = encoding1.decode(state)
    const r3 = encoding1.decode(state)
    const r4 = encoding1.decode(state)
    const r5 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      members: r0,
      pendingIndexers: r1,
      indexers: r2,
      heads: r3,
      views: r4,
      encryptionLength: r5,
      entropy: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/info
const encoding24 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding22.preencode(state, m)
        break
      case 2:
        encoding23.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding22.encode(state, m)
        break
      case 2:
        encoding23.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1: {
        const decoded = encoding22.decode(state, version)
        return decoded
      }
      case 2: {
        const decoded = encoding23.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/member
const encoding25 = {
  preencode (state, m) {
    state.end++ // max flag is 2 so always one byte
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    const flags =
      (m.isIndexer ? 1 : 0) |
      (m.isRemoved ? 2 : 0)

    c.uint.encode(state, flags)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const flags = c.uint.decode(state)

    return {
      isIndexer: (flags & 1) !== 0,
      isRemoved: (flags & 2) !== 0,
      length: c.uint.decode(state)
    }
  }
}

const encoding26 = external0.LinearizerKey

// @autobase/linearizerUpdate
const encoding27 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
    c.uint.preencode(state, m.batch)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 1 so always one byte
  },
  encode (state, m) {
    const flags = m.indexers ? 1 : 0

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
    c.uint.encode(state, m.batch)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)
  },
  decode (state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      key: r0,
      length: r1,
      batch: r2,
      systemLength: r3,
      indexers: (flags & 1) !== 0
    }
  }
}

// @autobase/encryptionDescriptor
const encoding28 = {
  preencode (state, m) {
    c.uint.preencode(state, m.type)
    c.uint.preencode(state, m.version)
    c.buffer.preencode(state, m.payload)
  },
  encode (state, m) {
    c.uint.encode(state, m.type)
    c.uint.encode(state, m.version)
    c.buffer.encode(state, m.payload)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.buffer.decode(state)

    return {
      type: r0,
      version: r1,
      payload: r2
    }
  }
}

// @autobase/manifestData
const encoding29 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    state.end++ // max flag is 1 so always one byte

    if (m.legacyBlocks) c.uint.preencode(state, m.legacyBlocks)
  },
  encode (state, m) {
    const flags = m.legacyBlocks ? 1 : 0

    c.uint.encode(state, m.version)
    c.uint.encode(state, flags)

    if (m.legacyBlocks) c.uint.encode(state, m.legacyBlocks)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version: r0,
      legacyBlocks: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

function setVersion (v) {
  version = v
}

function encode (name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode (name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum (name) {
  switch (name) {
    default: throw new Error('Enum not found ' + name)
  }
}

function getEncoding (name) {
  switch (name) {
    case '@autobase/checkout': return encoding0
    case '@autobase/clock': return encoding1
    case '@autobase/indexCheckpoint': return encoding2
    case '@autobase/wakeupLegacy': return encoding3
    case '@autobase/wakeupv2': return encoding4
    case '@autobase/wakeup': return encoding5
    case '@autobase/bootRecordLegacy': return encoding6
    case '@autobase/bootRecordv4': return encoding7
    case '@autobase/bootRecord': return encoding8
    case '@autobase/checkpointer': return encoding9
    case '@autobase/checkpointerArray': return encoding10
    case '@autobase/checkpoint': return encoding11
    case '@autobase/indexer': return encoding12
    case '@autobase/indexers': return encoding13
    case '@autobase/digest': return encoding14
    case '@autobase/node': return encoding15
    case '@autobase/additionalData': return encoding16
    case '@autobase/additional': return encoding17
    case '@autobase/oplogMessageLegacy': return encoding18
    case '@autobase/oplogMessagev2': return encoding19
    case '@autobase/oplogMessage': return encoding20
    case '@autobase/pendingIndexers': return encoding21
    case '@autobase/infoLegacy': return encoding22
    case '@autobase/infov2': return encoding23
    case '@autobase/info': return encoding24
    case '@autobase/member': return encoding25
    case '@autobase/linearizerKey': return encoding26
    case '@autobase/linearizerUpdate': return encoding27
    case '@autobase/encryptionDescriptor': return encoding28
    case '@autobase/manifestData': return encoding29
    default: throw new Error('Encoder not found ' + name)
  }
}

function getStruct (name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode (state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode (state, m) {
      version = v
      enc.encode(state, m)
    },
    decode (state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version }
