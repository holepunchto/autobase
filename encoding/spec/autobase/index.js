// This file is autogenerated by the hyperschema compiler
// Schema Version: 1
/* eslint-disable camelcase */
/* eslint-disable quotes */

const { c } = require('hyperschema/runtime')
const external0 = require('../../legacy.js')

const VERSION = 1

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @autobase/checkout
const encoding0 = {
  preencode(state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
  },
  encode(state, m) {
    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
  },
  decode(state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)

    return {
      key: r0,
      length: r1
    }
  }
}

// @autobase/clock
const encoding1 = c.array(encoding0)

// @autobase/index-checkpoint
const encoding2 = {
  preencode(state, m) {
    c.fixed64.preencode(state, m.signature)
    c.uint.preencode(state, m.length)
  },
  encode(state, m) {
    c.fixed64.encode(state, m.signature)
    c.uint.encode(state, m.length)
  },
  decode(state) {
    const r0 = c.fixed64.decode(state)
    const r1 = c.uint.decode(state)

    return {
      signature: r0,
      length: r1
    }
  }
}

const encoding3 = external0.Wakeup

const encoding4 = external0.BootRecordV0

// @autobase/boot-record-raw
const encoding5 = {
  preencode(state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 4 so always one byte

    if (m.recoveries) c.uint.preencode(state, m.recoveries)
  },
  encode(state, m) {
    const flags = (m.indexersUpdated ? 1 : 0) | (m.fastForwarding ? 2 : 0) | (m.recoveries ? 4 : 0)

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)

    if (m.recoveries) c.uint.encode(state, m.recoveries)
  },
  decode(state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      key: r0,
      systemLength: r1,
      indexersUpdated: (flags & 1) !== 0,
      fastForwarding: (flags & 2) !== 0,
      recoveries: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @autobase/boot-record
const encoding6 = {
  preencode(state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
        encoding4.preencode(state, m)
        break
      case 1:
      case 2:
      case 3:
        encoding5.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode(state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
        encoding4.encode(state, m)
        break
      case 1:
      case 2:
      case 3:
        encoding5.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode(state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0: {
        const decoded = encoding4.decode(state, version)
        return decoded
      }
      case 1:
      case 2:
      case 3: {
        const decoded = encoding5.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/checkpointer
const encoding7 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.checkpointer) c.uint.preencode(state, m.checkpointer)
    if (m.checkpoint) encoding2.preencode(state, m.checkpoint)
  },
  encode(state, m) {
    const flags = (m.checkpointer ? 1 : 0) | (m.checkpoint ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.checkpointer) c.uint.encode(state, m.checkpointer)
    if (m.checkpoint) encoding2.encode(state, m.checkpoint)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      checkpointer: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      checkpoint: (flags & 2) !== 0 ? encoding2.decode(state) : null
    }
  }
}

// @autobase/checkpoint.user
const encoding8_2 = c.array(encoding7)

// @autobase/checkpoint
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.system) encoding7.preencode(state, m.system)
    if (m.encryption) encoding7.preencode(state, m.encryption)
    if (m.user) encoding8_2.preencode(state, m.user)
  },
  encode(state, m) {
    const flags = (m.system ? 1 : 0) | (m.encryption ? 2 : 0) | (m.user ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.system) encoding7.encode(state, m.system)
    if (m.encryption) encoding7.encode(state, m.encryption)
    if (m.user) encoding8_2.encode(state, m.user)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      system: (flags & 1) !== 0 ? encoding7.decode(state) : null,
      encryption: (flags & 2) !== 0 ? encoding7.decode(state) : null,
      user: (flags & 4) !== 0 ? encoding8_2.decode(state) : null
    }
  }
}

// @autobase/digest
const encoding9 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.pointer) c.uint.preencode(state, m.pointer)
    if (m.key) c.fixed32.preencode(state, m.key)
  },
  encode(state, m) {
    const flags = (m.pointer ? 1 : 0) | (m.key ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.pointer) c.uint.encode(state, m.pointer)
    if (m.key) c.fixed32.encode(state, m.key)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      pointer: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      key: (flags & 2) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/node
const encoding10 = {
  preencode(state, m) {
    encoding1.preencode(state, m.heads)
    c.uint.preencode(state, m.batch)
    c.buffer.preencode(state, m.value)
  },
  encode(state, m) {
    encoding1.encode(state, m.heads)
    c.uint.encode(state, m.batch)
    c.buffer.encode(state, m.value)
  },
  decode(state) {
    const r0 = encoding1.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.buffer.decode(state)

    return {
      heads: r0,
      batch: r1,
      value: r2
    }
  }
}

// @autobase/trace.system
const encoding11_0 = c.array(c.uint)
// @autobase/trace.encryption
const encoding11_1 = encoding11_0

// @autobase/trace
const encoding11 = {
  preencode(state, m) {
    encoding11_0.preencode(state, m.system)
    encoding11_1.preencode(state, m.encryption)
    encoding11_2.preencode(state, m.user)
  },
  encode(state, m) {
    encoding11_0.encode(state, m.system)
    encoding11_1.encode(state, m.encryption)
    encoding11_2.encode(state, m.user)
  },
  decode(state) {
    const r0 = encoding11_0.decode(state)
    const r1 = encoding11_1.decode(state)
    const r2 = encoding11_2.decode(state)

    return {
      system: r0,
      encryption: r1,
      user: r2
    }
  }
}

const encoding12 = external0.OplogMessageV0

const encoding13 = external0.OplogMessageV1

// @autobase/oplog-message-v2.checkpoint
const encoding14_1 = c.frame(encoding8)
// @autobase/oplog-message-v2.digest
const encoding14_2 = c.frame(encoding9)
// @autobase/oplog-message-v2.trace
const encoding14_4 = c.frame(encoding11)

// @autobase/oplog-message-v2
const encoding14 = {
  preencode(state, m) {
    encoding10.preencode(state, m.node)
    state.end++ // max flag is 8 so always one byte

    if (m.checkpoint) encoding14_1.preencode(state, m.checkpoint)
    if (m.digest) encoding14_2.preencode(state, m.digest)
    if (m.trace) encoding14_4.preencode(state, m.trace)
  },
  encode(state, m) {
    const flags =
      (m.checkpoint ? 1 : 0) | (m.digest ? 2 : 0) | (m.optimistic ? 4 : 0) | (m.trace ? 8 : 0)

    encoding10.encode(state, m.node)
    c.uint.encode(state, flags)

    if (m.checkpoint) encoding14_1.encode(state, m.checkpoint)
    if (m.digest) encoding14_2.encode(state, m.digest)
    if (m.trace) encoding14_4.encode(state, m.trace)
  },
  decode(state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = encoding10.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      node: r0,
      checkpoint: (flags & 1) !== 0 ? encoding14_1.decode(state) : null,
      digest: (flags & 2) !== 0 ? encoding14_2.decode(state) : null,
      optimistic: (flags & 4) !== 0,
      trace: (flags & 8) !== 0 ? encoding14_4.decode(state) : null
    }
  }
}

// @autobase/oplog-message
const encoding15 = {
  preencode(state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
        encoding12.preencode(state, m)
        break
      case 1:
        encoding13.preencode(state, m)
        break
      case 2:
        encoding14.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode(state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
        encoding12.encode(state, m)
        break
      case 1:
        encoding13.encode(state, m)
        break
      case 2:
        encoding14.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode(state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0: {
        const decoded = encoding12.decode(state, version)
        return decoded
      }
      case 1: {
        const decoded = encoding13.decode(state, version)
        return decoded
      }
      case 2: {
        const decoded = encoding14.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/info-v1.pendingIndexers
const encoding16_1 = c.array(c.fixed32)

// @autobase/info-v1
const encoding16 = {
  preencode(state, m) {
    c.uint.preencode(state, m.members)
    encoding16_1.preencode(state, m.pendingIndexers)
    encoding1.preencode(state, m.indexers)
    encoding1.preencode(state, m.heads)
    encoding1.preencode(state, m.views)
  },
  encode(state, m) {
    c.uint.encode(state, m.members)
    encoding16_1.encode(state, m.pendingIndexers)
    encoding1.encode(state, m.indexers)
    encoding1.encode(state, m.heads)
    encoding1.encode(state, m.views)
  },
  decode(state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.uint.decode(state)
    const r1 = encoding16_1.decode(state)
    const r2 = encoding1.decode(state)
    const r3 = encoding1.decode(state)
    const r4 = encoding1.decode(state)

    return {
      version,
      members: r0,
      pendingIndexers: r1,
      indexers: r2,
      heads: r3,
      views: r4
    }
  }
}

// @autobase/info-v2.pendingIndexers
const encoding17_1 = encoding16_1

// @autobase/info-v2
const encoding17 = {
  preencode(state, m) {
    c.uint.preencode(state, m.members)
    encoding17_1.preencode(state, m.pendingIndexers)
    encoding1.preencode(state, m.indexers)
    encoding1.preencode(state, m.heads)
    encoding1.preencode(state, m.views)
    c.uint.preencode(state, m.encryptionLength)
    state.end++ // max flag is 1 so always one byte

    if (m.entropy) c.fixed32.preencode(state, m.entropy)
  },
  encode(state, m) {
    const flags = m.entropy ? 1 : 0

    c.uint.encode(state, m.members)
    encoding17_1.encode(state, m.pendingIndexers)
    encoding1.encode(state, m.indexers)
    encoding1.encode(state, m.heads)
    encoding1.encode(state, m.views)
    c.uint.encode(state, m.encryptionLength)
    c.uint.encode(state, flags)

    if (m.entropy) c.fixed32.encode(state, m.entropy)
  },
  decode(state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.uint.decode(state)
    const r1 = encoding17_1.decode(state)
    const r2 = encoding1.decode(state)
    const r3 = encoding1.decode(state)
    const r4 = encoding1.decode(state)
    const r5 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      members: r0,
      pendingIndexers: r1,
      indexers: r2,
      heads: r3,
      views: r4,
      encryptionLength: r5,
      entropy: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/info
const encoding18 = {
  preencode(state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding16.preencode(state, m)
        break
      case 2:
        encoding17.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode(state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding16.encode(state, m)
        break
      case 2:
        encoding17.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode(state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1: {
        const decoded = encoding16.decode(state, version)
        const map = external0.infoLegacyMap
        return map(decoded)
      }
      case 2: {
        const decoded = encoding17.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/member
const encoding19 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    c.uint.preencode(state, m.length)
  },
  encode(state, m) {
    const flags = (m.isIndexer ? 1 : 0) | (m.isRemoved ? 2 : 0)

    c.uint.encode(state, flags)
    c.uint.encode(state, m.length)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      isIndexer: (flags & 1) !== 0,
      isRemoved: (flags & 2) !== 0,
      length: c.uint.decode(state)
    }
  }
}

const encoding20 = external0.LinearizerKey

// @autobase/linearizer-update
const encoding21 = {
  preencode(state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
    c.uint.preencode(state, m.batch)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.indexers ? 1 : 0

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
    c.uint.encode(state, m.batch)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)
  },
  decode(state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      key: r0,
      length: r1,
      batch: r2,
      systemLength: r3,
      indexers: (flags & 1) !== 0
    }
  }
}

// @autobase/encryption-descriptor
const encoding22 = {
  preencode(state, m) {
    c.uint.preencode(state, m.type)
    c.buffer.preencode(state, m.payload)
  },
  encode(state, m) {
    c.uint.encode(state, m.type)
    c.buffer.encode(state, m.payload)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.buffer.decode(state)

    return {
      type: r0,
      payload: r1
    }
  }
}

// @autobase/manifest-data
const encoding23 = {
  preencode(state, m) {
    c.uint.preencode(state, m.version)
    state.end++ // max flag is 2 so always one byte

    if (m.legacyBlocks) c.uint.preencode(state, m.legacyBlocks)
    if (m.namespace) c.fixed32.preencode(state, m.namespace)
  },
  encode(state, m) {
    const flags = (m.legacyBlocks ? 1 : 0) | (m.namespace ? 2 : 0)

    c.uint.encode(state, m.version)
    c.uint.encode(state, flags)

    if (m.legacyBlocks) c.uint.encode(state, m.legacyBlocks)
    if (m.namespace) c.fixed32.encode(state, m.namespace)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version: r0,
      legacyBlocks: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      namespace: (flags & 2) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/user-view-trace.blocks
const encoding24_1 = encoding11_0

// @autobase/user-view-trace
const encoding24 = {
  preencode(state, m) {
    c.uint.preencode(state, m.view)
    encoding24_1.preencode(state, m.blocks)
  },
  encode(state, m) {
    c.uint.encode(state, m.view)
    encoding24_1.encode(state, m.blocks)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = encoding24_1.decode(state)

    return {
      view: r0,
      blocks: r1
    }
  }
}

// @autobase/trace.user, deferred due to recusive use
const encoding11_2 = c.array(encoding24)

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@autobase/checkout':
      return encoding0
    case '@autobase/clock':
      return encoding1
    case '@autobase/index-checkpoint':
      return encoding2
    case '@autobase/wakeup':
      return encoding3
    case '@autobase/boot-record-v0':
      return encoding4
    case '@autobase/boot-record-raw':
      return encoding5
    case '@autobase/boot-record':
      return encoding6
    case '@autobase/checkpointer':
      return encoding7
    case '@autobase/checkpoint':
      return encoding8
    case '@autobase/digest':
      return encoding9
    case '@autobase/node':
      return encoding10
    case '@autobase/trace':
      return encoding11
    case '@autobase/oplog-message-v0':
      return encoding12
    case '@autobase/oplog-message-v1':
      return encoding13
    case '@autobase/oplog-message-v2':
      return encoding14
    case '@autobase/oplog-message':
      return encoding15
    case '@autobase/info-v1':
      return encoding16
    case '@autobase/info-v2':
      return encoding17
    case '@autobase/info':
      return encoding18
    case '@autobase/member':
      return encoding19
    case '@autobase/linearizer-key':
      return encoding20
    case '@autobase/linearizer-update':
      return encoding21
    case '@autobase/encryption-descriptor':
      return encoding22
    case '@autobase/manifest-data':
      return encoding23
    case '@autobase/user-view-trace':
      return encoding24
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version
}
