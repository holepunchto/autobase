// This file is autogenerated by the hyperschema compiler
// Schema Version: 1
/* eslint-disable camelcase */
/* eslint-disable quotes */

const { c } = require('hyperschema/runtime')
const external0 = require('../../legacy.js')

const VERSION = 1

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @autobase/checkout
const encoding0 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)

    return {
      key: r0,
      length: r1
    }
  }
}

// @autobase/clock
const encoding1 = c.array(encoding0)

// @autobase/indexCheckpoint
const encoding2 = {
  preencode (state, m) {
    c.fixed64.preencode(state, m.signature)
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    c.fixed64.encode(state, m.signature)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const r0 = c.fixed64.decode(state)
    const r1 = c.uint.decode(state)

    return {
      signature: r0,
      length: r1
    }
  }
}

const encoding3 = external0.Wakeup

const encoding4 = external0.BootRecordV0

// @autobase/bootRecordRaw
const encoding5 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 4 so always one byte

    if (m.recoveries) c.uint.preencode(state, m.recoveries)
  },
  encode (state, m) {
    const flags =
      (m.indexersUpdated ? 1 : 0) |
      (m.fastForwarding ? 2 : 0) |
      (m.recoveries ? 4 : 0)

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)

    if (m.recoveries) c.uint.encode(state, m.recoveries)
  },
  decode (state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      key: r0,
      systemLength: r1,
      indexersUpdated: (flags & 1) !== 0,
      fastForwarding: (flags & 2) !== 0,
      recoveries: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @autobase/bootRecord
const encoding6 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
        encoding4.preencode(state, m)
        break
      case 1:
      case 2:
      case 3:
        encoding5.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
        encoding4.encode(state, m)
        break
      case 1:
      case 2:
      case 3:
        encoding5.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0: {
        const decoded = encoding4.decode(state, version)
        return decoded
      }
      case 1:
      case 2:
      case 3: {
        const decoded = encoding5.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/checkpointer
const encoding7 = {
  preencode (state, m) {
    c.uint.preencode(state, m.checkpointer)
    state.end++ // max flag is 1 so always one byte

    if (m.checkpoint) encoding2.preencode(state, m.checkpoint)
  },
  encode (state, m) {
    const flags = m.checkpoint ? 1 : 0

    c.uint.encode(state, m.checkpointer)
    c.uint.encode(state, flags)

    if (m.checkpoint) encoding2.encode(state, m.checkpoint)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      checkpointer: r0,
      checkpoint: (flags & 1) !== 0 ? encoding2.decode(state) : null
    }
  }
}

// @autobase/checkpoint.user
const encoding8_2 = c.array(encoding7)

// @autobase/checkpoint
const encoding8 = {
  preencode (state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.system) encoding7.preencode(state, m.system)
    if (m.encryption) encoding7.preencode(state, m.encryption)
    if (m.user) encoding8_2.preencode(state, m.user)
  },
  encode (state, m) {
    const flags =
      (m.system ? 1 : 0) |
      (m.encryption ? 2 : 0) |
      (m.user ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.system) encoding7.encode(state, m.system)
    if (m.encryption) encoding7.encode(state, m.encryption)
    if (m.user) encoding8_2.encode(state, m.user)
  },
  decode (state) {
    const flags = c.uint.decode(state)

    return {
      system: (flags & 1) !== 0 ? encoding7.decode(state) : null,
      encryption: (flags & 2) !== 0 ? encoding7.decode(state) : null,
      user: (flags & 4) !== 0 ? encoding8_2.decode(state) : null
    }
  }
}

// @autobase/digest
const encoding9 = {
  preencode (state, m) {
    c.uint.preencode(state, m.pointer)
    state.end++ // max flag is 1 so always one byte

    if (m.key) c.fixed32.preencode(state, m.key)
  },
  encode (state, m) {
    const flags = m.key ? 1 : 0

    c.uint.encode(state, m.pointer)
    c.uint.encode(state, flags)

    if (m.key) c.fixed32.encode(state, m.key)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      pointer: r0,
      key: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/node
const encoding10 = {
  preencode (state, m) {
    encoding1.preencode(state, m.heads)
    c.uint.preencode(state, m.batch)
    c.buffer.preencode(state, m.value)
  },
  encode (state, m) {
    encoding1.encode(state, m.heads)
    c.uint.encode(state, m.batch)
    c.buffer.encode(state, m.value)
  },
  decode (state) {
    const r0 = encoding1.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.buffer.decode(state)

    return {
      heads: r0,
      batch: r1,
      value: r2
    }
  }
}

const encoding11 = external0.OplogMessageV0

const encoding12 = external0.OplogMessageV1

// @autobase/oplogMessageV2.checkpoint
const encoding13_1 = c.frame(encoding8)
// @autobase/oplogMessageV2.digest
const encoding13_2 = c.frame(encoding9)

// @autobase/oplogMessageV2
const encoding13 = {
  preencode (state, m) {
    encoding10.preencode(state, m.node)
    state.end++ // max flag is 4 so always one byte

    if (m.checkpoint) encoding13_1.preencode(state, m.checkpoint)
    if (m.digest) encoding13_2.preencode(state, m.digest)
  },
  encode (state, m) {
    const flags =
      (m.checkpoint ? 1 : 0) |
      (m.digest ? 2 : 0) |
      (m.optimistic ? 4 : 0)

    encoding10.encode(state, m.node)
    c.uint.encode(state, flags)

    if (m.checkpoint) encoding13_1.encode(state, m.checkpoint)
    if (m.digest) encoding13_2.encode(state, m.digest)
  },
  decode (state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = encoding10.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      node: r0,
      checkpoint: (flags & 1) !== 0 ? encoding13_1.decode(state) : null,
      digest: (flags & 2) !== 0 ? encoding13_2.decode(state) : null,
      optimistic: (flags & 4) !== 0
    }
  }
}

// @autobase/oplogMessage
const encoding14 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
        encoding11.preencode(state, m)
        break
      case 1:
        encoding12.preencode(state, m)
        break
      case 2:
        encoding13.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
        encoding11.encode(state, m)
        break
      case 1:
        encoding12.encode(state, m)
        break
      case 2:
        encoding13.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0: {
        const decoded = encoding11.decode(state, version)
        return decoded
      }
      case 1: {
        const decoded = encoding12.decode(state, version)
        return decoded
      }
      case 2: {
        const decoded = encoding13.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

const encoding15 = external0.Info

// @autobase/infoV1.pendingIndexers
const encoding16_1 = c.array(c.fixed32)

// @autobase/infoV1
const encoding16 = {
  preencode (state, m) {
    c.uint.preencode(state, m.members)
    encoding16_1.preencode(state, m.pendingIndexers)
    encoding1.preencode(state, m.indexers)
    encoding1.preencode(state, m.heads)
    encoding1.preencode(state, m.views)
  },
  encode (state, m) {
    c.uint.encode(state, m.members)
    encoding16_1.encode(state, m.pendingIndexers)
    encoding1.encode(state, m.indexers)
    encoding1.encode(state, m.heads)
    encoding1.encode(state, m.views)
  },
  decode (state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.uint.decode(state)
    const r1 = encoding16_1.decode(state)
    const r2 = encoding1.decode(state)
    const r3 = encoding1.decode(state)
    const r4 = encoding1.decode(state)

    return {
      version,
      members: r0,
      pendingIndexers: r1,
      indexers: r2,
      heads: r3,
      views: r4
    }
  }
}

// @autobase/infoV2.pendingIndexers
const encoding17_1 = encoding16_1

// @autobase/infoV2
const encoding17 = {
  preencode (state, m) {
    c.uint.preencode(state, m.members)
    encoding17_1.preencode(state, m.pendingIndexers)
    encoding1.preencode(state, m.indexers)
    encoding1.preencode(state, m.heads)
    encoding1.preencode(state, m.views)
    c.uint.preencode(state, m.encryptionLength)
    state.end++ // max flag is 1 so always one byte

    if (m.entropy) c.fixed32.preencode(state, m.entropy)
  },
  encode (state, m) {
    const flags = m.entropy ? 1 : 0

    c.uint.encode(state, m.members)
    encoding17_1.encode(state, m.pendingIndexers)
    encoding1.encode(state, m.indexers)
    encoding1.encode(state, m.heads)
    encoding1.encode(state, m.views)
    c.uint.encode(state, m.encryptionLength)
    c.uint.encode(state, flags)

    if (m.entropy) c.fixed32.encode(state, m.entropy)
  },
  decode (state, version) {
    if (version === undefined) version = c.uint.decode(state)
    const r0 = c.uint.decode(state)
    const r1 = encoding17_1.decode(state)
    const r2 = encoding1.decode(state)
    const r3 = encoding1.decode(state)
    const r4 = encoding1.decode(state)
    const r5 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version,
      members: r0,
      pendingIndexers: r1,
      indexers: r2,
      heads: r3,
      views: r4,
      encryptionLength: r5,
      entropy: (flags & 1) !== 0 ? c.fixed32.decode(state) : null
    }
  }
}

// @autobase/info
const encoding18 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding16.preencode(state, m)
        break
      case 2:
        encoding17.preencode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  encode (state, m) {
    c.uint.encode(state, m.version)
    switch (m.version) {
      case 0:
      case 1:
        encoding16.encode(state, m)
        break
      case 2:
        encoding17.encode(state, m)
        break
      default:
        throw new Error('Unsupported version')
    }
  },
  decode (state) {
    const version = c.uint.decode(state)
    switch (version) {
      case 0:
      case 1: {
        const decoded = encoding16.decode(state, version)
        const map = external0.infoLegacyMap
        return map(decoded)
      }
      case 2: {
        const decoded = encoding17.decode(state, version)
        return decoded
      }
      default:
        throw new Error('Unsupported version')
    }
  }
}

// @autobase/member
const encoding19 = {
  preencode (state, m) {
    state.end++ // max flag is 2 so always one byte
    c.uint.preencode(state, m.length)
  },
  encode (state, m) {
    const flags =
      (m.isIndexer ? 1 : 0) |
      (m.isRemoved ? 2 : 0)

    c.uint.encode(state, flags)
    c.uint.encode(state, m.length)
  },
  decode (state) {
    const flags = c.uint.decode(state)

    return {
      isIndexer: (flags & 1) !== 0,
      isRemoved: (flags & 2) !== 0,
      length: c.uint.decode(state)
    }
  }
}

const encoding20 = external0.LinearizerKey

// @autobase/linearizerUpdate
const encoding21 = {
  preencode (state, m) {
    c.fixed32.preencode(state, m.key)
    c.uint.preencode(state, m.length)
    c.uint.preencode(state, m.batch)
    c.uint.preencode(state, m.systemLength)
    state.end++ // max flag is 1 so always one byte
  },
  encode (state, m) {
    const flags = m.indexers ? 1 : 0

    c.fixed32.encode(state, m.key)
    c.uint.encode(state, m.length)
    c.uint.encode(state, m.batch)
    c.uint.encode(state, m.systemLength)
    c.uint.encode(state, flags)
  },
  decode (state) {
    const r0 = c.fixed32.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      key: r0,
      length: r1,
      batch: r2,
      systemLength: r3,
      indexers: (flags & 1) !== 0
    }
  }
}

// @autobase/encryptionDescriptor
const encoding22 = {
  preencode (state, m) {
    c.uint.preencode(state, m.type)
    c.uint.preencode(state, m.version)
    c.buffer.preencode(state, m.payload)
  },
  encode (state, m) {
    c.uint.encode(state, m.type)
    c.uint.encode(state, m.version)
    c.buffer.encode(state, m.payload)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.buffer.decode(state)

    return {
      type: r0,
      version: r1,
      payload: r2
    }
  }
}

// @autobase/manifestData
const encoding23 = {
  preencode (state, m) {
    c.uint.preencode(state, m.version)
    state.end++ // max flag is 1 so always one byte

    if (m.legacyBlocks) c.uint.preencode(state, m.legacyBlocks)
  },
  encode (state, m) {
    const flags = m.legacyBlocks ? 1 : 0

    c.uint.encode(state, m.version)
    c.uint.encode(state, flags)

    if (m.legacyBlocks) c.uint.encode(state, m.legacyBlocks)
  },
  decode (state) {
    const r0 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      version: r0,
      legacyBlocks: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

function setVersion (v) {
  version = v
}

function encode (name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode (name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum (name) {
  switch (name) {
    default: throw new Error('Enum not found ' + name)
  }
}

function getEncoding (name) {
  switch (name) {
    case '@autobase/checkout': return encoding0
    case '@autobase/clock': return encoding1
    case '@autobase/indexCheckpoint': return encoding2
    case '@autobase/wakeup': return encoding3
    case '@autobase/bootRecordV0': return encoding4
    case '@autobase/bootRecordRaw': return encoding5
    case '@autobase/bootRecord': return encoding6
    case '@autobase/checkpointer': return encoding7
    case '@autobase/checkpoint': return encoding8
    case '@autobase/digest': return encoding9
    case '@autobase/node': return encoding10
    case '@autobase/oplogMessageV0': return encoding11
    case '@autobase/oplogMessageV1': return encoding12
    case '@autobase/oplogMessageV2': return encoding13
    case '@autobase/oplogMessage': return encoding14
    case '@autobase/infoLegacy': return encoding15
    case '@autobase/infoV1': return encoding16
    case '@autobase/infoV2': return encoding17
    case '@autobase/info': return encoding18
    case '@autobase/member': return encoding19
    case '@autobase/linearizerKey': return encoding20
    case '@autobase/linearizerUpdate': return encoding21
    case '@autobase/encryptionDescriptor': return encoding22
    case '@autobase/manifestData': return encoding23
    default: throw new Error('Encoder not found ' + name)
  }
}

function getStruct (name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode (state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode (state, m) {
      version = v
      enc.encode(state, m)
    },
    decode (state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version }
